use std::sync::Arc;
use std::time::Instant;
use axum::{
    Json, Router,
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
};
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use tokio::time::{timeout, Duration};
use uuid::Uuid;

/// Timeout for individual events (time between stdout lines)
const EVENT_TIMEOUT_SECS: u64 = 120; // 2 minutes between events
/// Maximum total time for a plan session
const SESSION_TIMEOUT_SECS: u64 = 600; // 10 minutes total

use eval_kanban_executor::{ClaudeExecutor, ExecutorEvent};
use eval_kanban_executor::claude::ClaudeProcess;

use crate::plan_session::{PlanSession, PlanSessionInfo, PlanQuestion, PlanAnswer, PlanStatus, QuestionOption, PLAN_MODE_SUFFIX};
use crate::state::AppState;
use crate::routes::ws::WsMessage;

#[derive(Serialize)]
struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
struct StartPlanRequest {
    title: String,
    prompt: String,
    session_id: String,  // Generated by frontend to avoid race condition
    /// Whether Claude should ask clarifying questions (uses PLAN_MODE_SUFFIX)
    #[serde(default)]
    ask_questions: bool,
}

#[derive(Serialize)]
struct StartPlanResponse {
    session_id: String,
}

#[derive(Deserialize)]
struct SingleAnswerRequest {
    question_index: usize,
    answers: Vec<String>,
}

#[derive(Deserialize)]
struct AnswerRequest {
    /// All answers for the batch of questions
    answers: Vec<SingleAnswerRequest>,
}

#[derive(Deserialize)]
struct ExecuteRequest {
    title: String,
    #[allow(dead_code)]
    description: Option<String>,
}

pub fn plan_router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/", post(start_plan))
        .route("/:session_id", get(get_plan).delete(cancel_plan))
        .route("/:session_id/answer", post(submit_answer))
        .route("/:session_id/execute", post(execute_plan))
        .route("/:session_id/redo", post(redo_plan))
        .route("/:session_id/resume", post(resume_plan))
}

async fn start_plan(
    State(state): State<Arc<AppState>>,
    Json(req): Json<StartPlanRequest>,
) -> Result<Json<StartPlanResponse>, (StatusCode, Json<ErrorResponse>)> {
    let session_id = req.session_id;

    tracing::info!("[Plan {}] Starting plan session (ask_questions={})", session_id, req.ask_questions);
    tracing::info!("[Plan {}] Title: {}", session_id, req.title);

    let session = PlanSession::new(session_id.clone(), req.title.clone(), req.prompt.clone(), req.ask_questions);
    state.add_plan_session(session).await;

    // Spawn Claude with the initial prompt
    spawn_claude_for_session(state, session_id.clone(), false).await;

    Ok(Json(StartPlanResponse { session_id }))
}

/// Spawn Claude for a planning session (used for initial spawn and re-spawn after answer)
async fn spawn_claude_for_session(state: Arc<AppState>, session_id: String, is_respawn: bool) {
    // Build prompt based on whether this is initial or re-spawn
    let prompt = {
        let sessions = state.plan_sessions.read().await;
        match sessions.get(&session_id) {
            Some(session) => {
                let base_prompt = if is_respawn {
                    // Re-spawn: include conversation history
                    session.build_respawn_prompt()
                } else {
                    // Initial spawn
                    session.prompt.clone()
                };

                // Only add PLAN_MODE_SUFFIX if ask_questions is enabled
                if session.ask_questions {
                    format!("{}{}", base_prompt, PLAN_MODE_SUFFIX)
                } else {
                    base_prompt
                }
            }
            None => {
                tracing::error!("[Plan {}] Session not found for spawn", session_id);
                return;
            }
        }
    };

    tracing::info!("[Plan {}] {} Claude (prompt length: {})",
        session_id,
        if is_respawn { "Re-spawning" } else { "Spawning" },
        prompt.len()
    );

    let working_dir = state.working_dir.clone();
    let executor = ClaudeExecutor::new(working_dir);

    match executor.spawn_interactive(&prompt).await {
        Ok((rx, process, _stdin_tx)) => {
            tracing::info!("[Plan {}] Claude spawned successfully", session_id);

            // Update session status
            state.update_plan_session(&session_id, |s| {
                s.status = PlanStatus::Processing;
            }).await;

            // Process events in background
            let state_clone = state.clone();
            let session_id_clone = session_id.clone();
            tokio::spawn(async move {
                handle_plan_executor_events(state_clone, session_id_clone, rx, process).await;
            });
        }
        Err(e) => {
            tracing::error!("[Plan {}] Failed to spawn Claude: {}", session_id, e);
            state.update_plan_session(&session_id, |s| {
                s.status = PlanStatus::Error;
            }).await;
            state.broadcast(WsMessage::PlanError {
                session_id,
                error: format!("Failed to spawn Claude: {}", e),
            }).await;
        }
    }
}

async fn handle_plan_executor_events(
    state: Arc<AppState>,
    session_id: String,
    mut rx: mpsc::Receiver<ExecutorEvent>,
    mut process: ClaudeProcess,
) {
    let mut stdout_line_count = 0;
    let mut stderr_line_count = 0;
    let session_start = Instant::now();

    tracing::info!("[Plan {}] Starting event handler (timeout: {}s per event, {}s total)",
        session_id, EVENT_TIMEOUT_SECS, SESSION_TIMEOUT_SECS);

    loop {
        // Check total session timeout
        if session_start.elapsed().as_secs() > SESSION_TIMEOUT_SECS {
            tracing::error!("[Plan {}] Session timeout after {}s", session_id, SESSION_TIMEOUT_SECS);
            let _ = process.try_kill();
            state.update_plan_session(&session_id, |s| {
                s.status = PlanStatus::Error;
            }).await;
            state.broadcast(WsMessage::PlanError {
                session_id: session_id.clone(),
                error: format!("Planning session timed out after {} minutes", SESSION_TIMEOUT_SECS / 60),
            }).await;
            break;
        }

        // Wait for next event with timeout
        let event_result = timeout(
            Duration::from_secs(EVENT_TIMEOUT_SECS),
            rx.recv()
        ).await;

        let event = match event_result {
            Ok(Some(event)) => event,
            Ok(None) => {
                // Channel closed, process ended
                tracing::info!("[Plan {}] Event channel closed", session_id);
                break;
            }
            Err(_) => {
                // Timeout waiting for event - check if we're waiting for answer
                let status = {
                    let sessions = state.plan_sessions.read().await;
                    sessions.get(&session_id).map(|s| s.status.clone())
                };

                if status == Some(PlanStatus::WaitingForAnswer) {
                    // This is expected - we killed the process after finding a question
                    tracing::info!("[Plan {}] Timeout while waiting for answer (expected)", session_id);
                    break;
                }

                tracing::error!("[Plan {}] Timeout waiting for event ({}s)", session_id, EVENT_TIMEOUT_SECS);
                let _ = process.try_kill();
                state.update_plan_session(&session_id, |s| {
                    s.status = PlanStatus::Error;
                }).await;
                state.broadcast(WsMessage::PlanError {
                    session_id: session_id.clone(),
                    error: format!("Claude stopped responding (no output for {} minutes)", EVENT_TIMEOUT_SECS / 60),
                }).await;
                break;
            }
        };

        match &event {
            ExecutorEvent::Stdout(line) => {
                stdout_line_count += 1;
                let truncated = if line.len() > 200 {
                    // Safe UTF-8 truncation: find char boundary
                    let mut end = 200;
                    while end > 0 && !line.is_char_boundary(end) {
                        end -= 1;
                    }
                    format!("{}...", &line[..end])
                } else {
                    line.clone()
                };
                tracing::info!("[Plan {}] Stdout #{}: {}", session_id, stdout_line_count, truncated);

                // Accumulate output in session
                state.update_plan_session(&session_id, |s| {
                    s.append_output(line);
                }).await;

                // Try to parse AskUserQuestion tool calls from the output
                let questions = parse_ask_user_questions(line);
                if !questions.is_empty() {
                    tracing::info!("[Plan {}] Found AskUserQuestion with {} questions! Stopping process to wait for user answers.", session_id, questions.len());

                    // Get current question base index and update session
                    let base_index = {
                        let sessions = state.plan_sessions.read().await;
                        sessions.get(&session_id)
                            .map(|s| s.current_question_index())
                            .unwrap_or(0)
                    };

                    // Adjust indices and add all questions to session
                    let indexed_questions: Vec<PlanQuestion> = questions.into_iter()
                        .enumerate()
                        .map(|(i, mut q)| {
                            q.index = base_index + i;
                            q
                        })
                        .collect();

                    // Add all questions and set status to waiting
                    state.update_plan_session(&session_id, |s| {
                        s.add_questions(indexed_questions.clone());
                    }).await;

                    // Broadcast all questions via WebSocket
                    tracing::info!("[Plan {}] Broadcasting {} PlanQuestions to WebSocket", session_id, indexed_questions.len());
                    state.broadcast(WsMessage::PlanQuestions {
                        session_id: session_id.clone(),
                        questions: indexed_questions,
                    }).await;

                    // Kill the process - we'll re-spawn after user answers
                    tracing::info!("[Plan {}] Killing process to wait for user answers", session_id);
                    let _ = process.try_kill();
                    break;
                }

                // Check for Write tool writing to .claude/plans/ (plan file)
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(line) {
                    if json.get("type").and_then(|t| t.as_str()) == Some("assistant") {
                        if let Some(content) = json.get("message")
                            .and_then(|m| m.get("content"))
                            .and_then(|c| c.as_array())
                        {
                            for item in content {
                                if item.get("type").and_then(|t| t.as_str()) == Some("tool_use") {
                                    let tool_name = item.get("name").and_then(|n| n.as_str());

                                    if tool_name == Some("Write") {
                                        if let Some(input) = item.get("input") {
                                            let file_path = input.get("file_path").and_then(|p| p.as_str()).unwrap_or("");

                                            // Check if it's a plan file
                                            if file_path.contains(".claude/plans") || file_path.contains(".claude\\plans") {
                                                if let Some(plan_content) = input.get("content").and_then(|c| c.as_str()) {
                                                    tracing::info!("[Plan {}] Captured plan file content ({} chars) from Write tool", session_id, plan_content.len());
                                                    state.update_plan_session(&session_id, |s| {
                                                        s.plan_content = Some(plan_content.to_string());
                                                    }).await;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Broadcast output for real-time display
                state.broadcast(WsMessage::PlanOutput {
                    session_id: session_id.clone(),
                    content: line.clone(),
                }).await;

                // Check for completion event: {"type":"result","subtype":"success","result":"..."}
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(line) {
                    if json.get("type").and_then(|t| t.as_str()) == Some("result")
                        && json.get("subtype").and_then(|t| t.as_str()) == Some("success")
                    {
                        tracing::info!("[Plan {}] Detected success result event! Extracting summary...", session_id);

                        // Get plan_content from session (if Claude wrote a plan file)
                        let summary = {
                            let sessions = state.plan_sessions.read().await;
                            sessions.get(&session_id)
                                .and_then(|s| s.plan_content.clone())
                                .unwrap_or_else(|| {
                                    // Fallback: use the result if no plan file was written
                                    json.get("result").and_then(|r| r.as_str()).unwrap_or("").to_string()
                                })
                        };

                        if !summary.is_empty() {
                            let source = {
                                let sessions = state.plan_sessions.read().await;
                                if sessions.get(&session_id).and_then(|s| s.plan_content.as_ref()).is_some() {
                                    "plan file"
                                } else {
                                    "result event"
                                }
                            };
                            tracing::info!("[Plan {}] Using summary from {} ({} chars)", session_id, source, summary.len());

                            // Update session with summary
                            state.update_plan_session(&session_id, |s| {
                                s.set_summary(summary.clone());
                            }).await;

                            // Broadcast summary via WebSocket
                            tracing::info!("[Plan {}] Broadcasting PlanSummary ({} chars)", session_id, summary.len());
                            state.broadcast(WsMessage::PlanSummary {
                                session_id: session_id.clone(),
                                summary,
                            }).await;
                        }

                        // Process will end soon, we can exit the loop
                        break;
                    }
                }
            }
            ExecutorEvent::Stderr(line) => {
                stderr_line_count += 1;
                tracing::warn!("[Plan {}] Stderr #{}: {}", session_id, stderr_line_count, line);
                state.broadcast(WsMessage::PlanOutput {
                    session_id: session_id.clone(),
                    content: format!("[stderr] {}", line),
                }).await;
            }
            ExecutorEvent::Started => {
                tracing::info!("[Plan {}] Received Started event", session_id);
            }
            ExecutorEvent::Completed { success } => {
                tracing::info!(
                    "[Plan {}] Completed: success={}, stdout_lines={}, stderr_lines={}, duration={}s",
                    session_id, success, stdout_line_count, stderr_line_count,
                    session_start.elapsed().as_secs()
                );

                // Check if we're waiting for answer (normal exit after question)
                let status = {
                    let sessions = state.plan_sessions.read().await;
                    sessions.get(&session_id).map(|s| s.status.clone())
                };

                if status == Some(PlanStatus::WaitingForAnswer) {
                    tracing::info!("[Plan {}] Process ended while waiting for answer (expected)", session_id);
                    break;
                }

                if *success {
                    // Process completed without asking questions - extract summary
                    let summary = {
                        let sessions = state.plan_sessions.read().await;
                        sessions.get(&session_id)
                            .map(|s| extract_summary(&s.accumulated_output))
                            .unwrap_or_default()
                    };

                    if !summary.is_empty() {
                        tracing::info!("[Plan {}] Extracted summary ({} chars)", session_id, summary.len());
                        state.update_plan_session(&session_id, |s| {
                            s.set_summary(summary.clone());
                        }).await;
                        state.broadcast(WsMessage::PlanSummary {
                            session_id: session_id.clone(),
                            summary,
                        }).await;
                    } else {
                        tracing::warn!("[Plan {}] No summary extracted from output", session_id);
                    }
                } else {
                    tracing::error!("[Plan {}] Process failed!", session_id);
                    state.update_plan_session(&session_id, |s| {
                        s.status = PlanStatus::Error;
                    }).await;
                    state.broadcast(WsMessage::PlanError {
                        session_id: session_id.clone(),
                        error: "Planning process failed".to_string(),
                    }).await;
                }
                break;
            }
            ExecutorEvent::Error(msg) => {
                tracing::error!("[Plan {}] Error event: {}", session_id, msg);
            }
        }
    }

    tracing::info!("[Plan {}] Event handler finished (total duration: {}s)",
        session_id, session_start.elapsed().as_secs());
}

/// Parse AskUserQuestion tool calls from Claude's stream-json output
/// Handles multiple possible JSON formats from Claude Code CLI
/// Returns all questions from the AskUserQuestion (up to 4)
fn parse_ask_user_questions(line: &str) -> Vec<PlanQuestion> {
    // Try to parse the line as JSON
    let json: serde_json::Value = match serde_json::from_str(line) {
        Ok(v) => v,
        Err(_e) => {
            // Not JSON - might be plain text output
            if !line.trim().is_empty() && !line.starts_with('{') {
                tracing::debug!("[Plan Parse] Non-JSON line: {}", line);
            }
            return Vec::new();
        }
    };

    let event_type = json.get("type").and_then(|t| t.as_str());
    tracing::debug!("[Plan Parse] JSON event type: {:?}", event_type);

    // Try to extract tool_use data from different possible formats
    let tool_use_data = match event_type {
        // Format 1: Direct tool_use event
        Some("tool_use") => {
            tracing::debug!("[Plan Parse] Found direct tool_use event");
            Some(json.clone())
        }
        // Format 2: Nested in content_block_start
        Some("content_block_start") => {
            tracing::debug!("[Plan Parse] Found content_block_start, checking for nested tool_use");
            json.get("content_block")
                .filter(|cb| cb.get("type").and_then(|t| t.as_str()) == Some("tool_use"))
                .cloned()
        }
        // Format 3: Claude stream-json format - {"type":"assistant","message":{"content":[{"type":"tool_use",...}]}}
        Some("assistant") => {
            tracing::debug!("[Plan Parse] Found assistant event, checking message.content array");
            json.get("message")
                .and_then(|m| m.get("content"))
                .and_then(|c| c.as_array())
                .and_then(|arr| {
                    arr.iter().find(|item| {
                        item.get("type").and_then(|t| t.as_str()) == Some("tool_use")
                    }).cloned()
                })
        }
        // Format 4: Direct content array (fallback)
        Some("message") => {
            tracing::debug!("[Plan Parse] Found message event, checking content array");
            json.get("content")
                .and_then(|c| c.as_array())
                .and_then(|arr| {
                    arr.iter().find(|item| {
                        item.get("type").and_then(|t| t.as_str()) == Some("tool_use")
                    }).cloned()
                })
        }
        _ => {
            if event_type.is_some() {
                tracing::debug!("[Plan Parse] Unhandled event type: {:?}", event_type);
            }
            None
        }
    };

    let tool_data = match tool_use_data {
        Some(data) => data,
        None => return Vec::new(),
    };

    // Check if it's AskUserQuestion
    let tool_name = tool_data.get("name").and_then(|n| n.as_str());
    if tool_name != Some("AskUserQuestion") {
        if tool_name.is_some() {
            tracing::info!("[Plan Parse] Tool use for different tool: {:?}", tool_name);
        }
        return Vec::new();
    }

    tracing::info!("[Plan Parse] Found AskUserQuestion tool use!");

    // Capture the tool_use_id - required for sending tool_result back
    let tool_use_id = match tool_data.get("id").and_then(|id| id.as_str()) {
        Some(id) => {
            tracing::debug!("[Plan Parse] Tool use ID: {}", id);
            id.to_string()
        }
        None => {
            tracing::warn!("[Plan Parse] AskUserQuestion missing 'id' field");
            return Vec::new();
        }
    };

    let input = match tool_data.get("input") {
        Some(i) => i,
        None => {
            tracing::warn!("[Plan Parse] AskUserQuestion missing 'input' field");
            return Vec::new();
        }
    };

    let questions_arr = match input.get("questions").and_then(|q| q.as_array()) {
        Some(q) => q,
        None => {
            tracing::warn!("[Plan Parse] AskUserQuestion missing 'questions' array");
            return Vec::new();
        }
    };

    if questions_arr.is_empty() {
        tracing::warn!("[Plan Parse] AskUserQuestion has empty questions array");
        return Vec::new();
    }

    // Parse ALL questions from the array (up to 4)
    let mut parsed_questions = Vec::new();

    for (idx, q) in questions_arr.iter().enumerate() {
        let question_text = match q.get("question").and_then(|q| q.as_str()) {
            Some(text) => text.to_string(),
            None => {
                tracing::warn!("[Plan Parse] Question {} missing 'question' field", idx);
                continue;
            }
        };

        let header = q.get("header").and_then(|h| h.as_str()).unwrap_or("Question").to_string();
        let multi_select = q.get("multiSelect").and_then(|m| m.as_bool()).unwrap_or(false);

        let options: Vec<QuestionOption> = q.get("options")
            .and_then(|o| o.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|opt| {
                        Some(QuestionOption {
                            label: opt.get("label")?.as_str()?.to_string(),
                            description: opt.get("description").and_then(|d| d.as_str()).unwrap_or("").to_string(),
                        })
                    })
                    .collect()
            })
            .unwrap_or_default();

        tracing::info!(
            "[Plan Parse] Parsed question {}: header='{}', options={}, multi_select={}",
            idx, header, options.len(), multi_select
        );

        parsed_questions.push(PlanQuestion {
            index: idx,
            question: question_text,
            header,
            options,
            multi_select,
            tool_use_id: tool_use_id.clone(),
        });
    }

    tracing::info!("[Plan Parse] Successfully parsed {} questions", parsed_questions.len());
    parsed_questions
}

/// Extract the final summary from Claude's JSON output
fn extract_summary(output: &str) -> String {
    // Look for summary in JSON events (all Claude output is JSON)
    for line in output.lines().rev() {
        let Ok(json) = serde_json::from_str::<serde_json::Value>(line) else {
            continue;
        };

        // Format 1: {"type":"result","subtype":"success","result":"..."}
        if json.get("type").and_then(|t| t.as_str()) == Some("result")
            && json.get("subtype").and_then(|t| t.as_str()) == Some("success")
        {
            if let Some(result) = json.get("result").and_then(|r| r.as_str()) {
                tracing::info!("[Plan] Extracted summary from result event ({} chars)", result.len());
                return result.to_string();
            }
        }

        // Format 2: Assistant text in {"type":"assistant","message":{"content":[{"type":"text","text":"..."}]}}
        if json.get("type").and_then(|t| t.as_str()) == Some("assistant") {
            if let Some(content) = json.get("message")
                .and_then(|m| m.get("content"))
                .and_then(|c| c.as_array())
            {
                for item in content {
                    if item.get("type").and_then(|t| t.as_str()) == Some("text") {
                        if let Some(text) = item.get("text").and_then(|t| t.as_str()) {
                            // Return last substantial text as summary
                            if text.len() > 50 {
                                tracing::info!("[Plan] Extracted summary from assistant text ({} chars)", text.len());
                                return text.to_string();
                            }
                        }
                    }
                }
            }
        }
    }

    tracing::warn!("[Plan] No summary found in output");
    String::new()
}

async fn get_plan(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
) -> Result<Json<PlanSessionInfo>, (StatusCode, Json<ErrorResponse>)> {
    match state.get_plan_session_info(&session_id).await {
        Some(info) => Ok(Json(info)),
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan session not found".to_string(),
            }),
        )),
    }
}

async fn submit_answer(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
    Json(req): Json<AnswerRequest>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    tracing::info!(
        "[Plan {}] Received {} answers",
        session_id, req.answers.len()
    );

    // Convert to PlanAnswer objects
    let answers: Vec<PlanAnswer> = req.answers.into_iter()
        .map(|a| {
            tracing::info!("[Plan {}] Question {}: {:?}", session_id, a.question_index, a.answers);
            PlanAnswer {
                question_index: a.question_index,
                answers: a.answers,
            }
        })
        .collect();

    // Add all answers to the session
    let updated = state.update_plan_session(&session_id, |s| {
        s.add_answers(answers);
    }).await;

    if !updated {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan session not found".to_string(),
            }),
        ));
    }

    tracing::info!("[Plan {}] All answers added, re-spawning Claude with context", session_id);

    // Re-spawn Claude with the updated prompt including the answers
    spawn_claude_for_session(state, session_id, true).await;

    Ok(StatusCode::ACCEPTED)
}

async fn execute_plan(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
    Json(req): Json<ExecuteRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    // Get and remove the session
    let session = state.remove_plan_session(&session_id).await;

    let session = match session {
        Some(s) => s,
        None => {
            return Err((
                StatusCode::NOT_FOUND,
                Json(ErrorResponse {
                    error: "Plan session not found".to_string(),
                }),
            ));
        }
    };

    // Build the full description with Q&A context
    let mut full_description = session.prompt.clone();

    if !session.questions.is_empty() {
        full_description.push_str("\n\n## Interview Answers\n\n");
        for (q, a) in session.questions.iter().zip(session.answers.iter()) {
            full_description.push_str(&format!("**{}**: {}\n", q.header, q.question));
            full_description.push_str(&format!("Answer: {}\n\n", a.answers.join(", ")));
        }
    }

    if let Some(summary) = &session.summary {
        full_description.push_str("\n\n## Implementation Plan\n\n");
        full_description.push_str(summary);
    }

    // Create the task
    use eval_kanban_db::{CreateTask, Task};

    let task = Task::create(
        &state.db,
        CreateTask {
            title: req.title,
            description: Some(full_description),
        },
    )
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: e.to_string(),
            }),
        )
    })?;

    // Broadcast task creation
    state.broadcast(WsMessage::TaskUpdated { task: task.clone() }).await;

    Ok(Json(serde_json::json!({
        "task_id": task.id,
        "message": "Task created from plan"
    })))
}

async fn cancel_plan(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let session = state.remove_plan_session(&session_id).await;

    if session.is_some() {
        // Process will be killed on drop
        Ok(StatusCode::NO_CONTENT)
    } else {
        Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan session not found".to_string(),
            }),
        ))
    }
}

async fn redo_plan(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
) -> Result<Json<StartPlanResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get the current session info
    let info = state.get_plan_session_info(&session_id).await;

    let info = match info {
        Some(i) => i,
        None => {
            return Err((
                StatusCode::NOT_FOUND,
                Json(ErrorResponse {
                    error: "Plan session not found".to_string(),
                }),
            ));
        }
    };

    // Cancel the current session
    state.remove_plan_session(&session_id).await;

    // Start a new one with the same prompt (generate new session_id for redo)
    start_plan(
        State(state),
        Json(StartPlanRequest {
            title: info.title,
            prompt: info.prompt,
            session_id: Uuid::new_v4().to_string(),
            ask_questions: info.ask_questions,
        }),
    ).await
}

/// Resume a plan session after error (preserves Q&A history)
async fn resume_plan(
    State(state): State<Arc<AppState>>,
    Path(session_id): Path<String>,
) -> Result<Json<StartPlanResponse>, (StatusCode, Json<ErrorResponse>)> {
    tracing::info!("[Plan {}] Resuming plan session", session_id);

    // Verify session exists (DO NOT remove it - we want to preserve Q&A history!)
    let exists = state.get_plan_session_info(&session_id).await.is_some();
    if !exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan session not found".to_string(),
            }),
        ));
    }

    // Reset status to Processing
    state.update_plan_session(&session_id, |s| {
        s.status = PlanStatus::Processing;
    }).await;

    // Re-spawn Claude with history (is_respawn=true uses build_respawn_prompt)
    spawn_claude_for_session(state, session_id.clone(), true).await;

    Ok(Json(StartPlanResponse { session_id }))
}
